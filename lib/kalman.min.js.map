{"version":3,"sources":["../src/kalman.js"],"names":["KalmanFilter","_ref","arguments","length","undefined","_ref$R","R","_ref$Q","Q","_ref$A","A","_ref$B","B","_ref$C","C","_classCallCheck","this","cov","NaN","x","z","u","isNaN","predX","predict","predCov","uncertainty","K","noise"],"mappings":";obAUqBA,wBAWnB,QAAAA,KAAsD,GAAAC,GAAAC,UAAAC,OAAA,OAAAC,KAAAF,UAAA,GAAAA,UAAA,MAAAG,EAAAJ,EAAzCK,EAAAA,MAAyCF,KAAAC,EAArC,EAAqCA,EAAAE,EAAAN,EAAlCO,EAAAA,MAAkCJ,KAAAG,EAA9B,EAA8BA,EAAAE,EAAAR,EAA3BS,EAAAA,MAA2BN,KAAAK,EAAvB,EAAuBA,EAAAE,EAAAV,EAApBW,EAAAA,MAAoBR,KAAAO,EAAhB,EAAgBA,EAAAE,EAAAZ,EAAba,EAAAA,MAAaV,KAAAS,EAAT,EAASA,CAAAE,iBAAAC,KAAAhB,GAEpDgB,KAAKV,EAAIA,EACTU,KAAKR,EAAIA,EAETQ,KAAKN,EAAIA,EACTM,KAAKF,EAAIA,EACTE,KAAKJ,EAAIA,EACTI,KAAKC,IAAMC,IACXF,KAAKG,EAAID,wDASJE,GAAU,GAAPC,GAAOnB,UAAAC,OAAA,OAAAC,KAAAF,UAAA,GAAAA,UAAA,GAAH,CAEZ,IAAIoB,MAAMN,KAAKG,GACbH,KAAKG,EAAK,EAAIH,KAAKF,EAAKM,EACxBJ,KAAKC,IAAO,EAAID,KAAKF,EAAKE,KAAKR,GAAK,EAAIQ,KAAKF,OAE1C,CAGH,GAAMS,GAAQP,KAAKQ,QAAQH,GACrBI,EAAUT,KAAKU,cAGfC,EAAIF,EAAUT,KAAKF,GAAK,GAAME,KAAKF,EAAIW,EAAUT,KAAKF,EAAKE,KAAKR,GAGtEQ,MAAKG,EAAII,EAAQI,GAAKP,EAAKJ,KAAKF,EAAIS,GACpCP,KAAKC,IAAMQ,EAAWE,EAAIX,KAAKF,EAAIW,EAGrC,MAAOT,MAAKG,oCAQC,GAAPE,GAAOnB,UAAAC,OAAA,OAAAC,KAAAF,UAAA,GAAAA,UAAA,GAAH,CACV,OAAQc,MAAKN,EAAIM,KAAKG,EAAMH,KAAKJ,EAAIS,wCAQrC,MAASL,MAAKN,EAAIM,KAAKC,IAAOD,KAAKN,EAAKM,KAAKV,4CAQ7C,MAAOU,MAAKG,8CAOMS,GAClBZ,KAAKR,EAAIoB,0CAOKA,GACdZ,KAAKV,EAAIsB,2BA1FQ5B","file":"lib/kalman.min.js","sourcesContent":["/**\n* KalmanFilter\n* @class\n* @author Wouter Bulten\n* @see {@link http://github.com/wouterbulten/kalmanjs}\n* @version Version: 1.0.0-beta\n* @copyright Copyright 2015-2018 Wouter Bulten\n* @license MIT License\n* @preserve\n*/\nexport default class KalmanFilter {\n\n  /**\n  * Create 1-dimensional kalman filter\n  * @param  {Number} options.R Process noise\n  * @param  {Number} options.Q Measurement noise\n  * @param  {Number} options.A State vector\n  * @param  {Number} options.B Control vector\n  * @param  {Number} options.C Measurement vector\n  * @return {KalmanFilter}\n  */\n  constructor({R = 1, Q = 1, A = 1, B = 0, C = 1} = {}) {\n\n    this.R = R; // noise power desirable\n    this.Q = Q; // noise power estimated\n\n    this.A = A;\n    this.C = C;\n    this.B = B;\n    this.cov = NaN;\n    this.x = NaN; // estimated signal without noise\n  }\n\n  /**\n  * Filter a new value\n  * @param  {Number} z Measurement\n  * @param  {Number} u Control\n  * @return {Number}\n  */\n  filter(z, u = 0) {\n\n    if (isNaN(this.x)) {\n      this.x = (1 / this.C) * z;\n      this.cov = (1 / this.C) * this.Q * (1 / this.C);\n    }\n    else {\n\n      // Compute prediction\n      const predX = this.predict(u);\n      const predCov = this.uncertainty();\n\n      // Kalman gain\n      const K = predCov * this.C * (1 / ((this.C * predCov * this.C) + this.Q));\n\n      // Correction\n      this.x = predX + K * (z - (this.C * predX));\n      this.cov = predCov - (K * this.C * predCov);\n    }\n\n    return this.x;\n  }\n\n  /**\n  * Predict next value\n  * @param  {Number} [u] Control\n  * @return {Number}\n  */\n  predict(u = 0) {\n    return (this.A * this.x) + (this.B * u);\n  }\n  \n  /**\n  * Return uncertainty of filter\n  * @return {Number}\n  */\n  uncertainty() {\n    return ((this.A * this.cov) * this.A) + this.R;\n  }\n  \n  /**\n  * Return the last filtered measurement\n  * @return {Number}\n  */\n  lastMeasurement() {\n    return this.x;\n  }\n\n  /**\n  * Set measurement noise Q\n  * @param {Number} noise\n  */\n  setMeasurementNoise(noise) {\n    this.Q = noise;\n  }\n\n  /**\n  * Set the process noise R\n  * @param {Number} noise\n  */\n  setProcessNoise(noise) {\n    this.R = noise;\n  }\n}\n"]}